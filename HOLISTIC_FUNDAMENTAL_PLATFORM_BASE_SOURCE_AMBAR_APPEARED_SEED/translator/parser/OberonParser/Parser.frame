/*-------------------------------------------------------------------------
Oberon suite
Copyright (c) 2012, 2014 Evgeniy Grigorievitch Philippov. All Rights Reserved.

***

Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin
#if !defined(-->prefixCOCO_PARSER_H)
#define -->prefixCOCO_PARSER_H

-->headerdef
#include "Scanner.h"

/* -->namespace_open */
class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);

}; // Errors

namespace ModTab{class ModuleTable;}

class Parser {
public:
	ModTab::ModuleTable* modtab;
	ModTab::ModuleTable* getmodtab(){return modtab;}
//public:
	//void addParserListener(const ParserListener *const parserListener){this->parserListener=parserListener;}
private:
-->constantsheader
	//const ParserListener *parserListener;
	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

-->declarations

	Parser(Scanner *scanner, Errors* errors_);
	~Parser();
	void SemErr(const wchar_t* msg);

-->productionsheader
	void Parse();

}; // end Parser

/* -->namespace_close */

#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin

#include "Parser.h"
#include "Scanner.h"
#include "ModuleTable.h"
#include "SymbolTable.h"
#include "../generator/CodeGenerator.h"


/* -->namespace_open */

void Parser::SynErr(int n) {
	//if (errDist >= minErrDist)
		errors->SynErr(la->line, la->col, n);
	errDist = 0;
}

void Parser::SemErr(const wchar_t* msg) {
	//if (errDist >= minErrDist)
		errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }
-->pragmas
		if (dummyToken != t) {
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}

void Parser::Expect(int n) {
	if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

-->productions


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();
-->parseRoot
}

Parser::Parser(Scanner *scanner, Errors* errors_) {
	//parserListener=0;
-->constants
	ParserInitCaller<Parser>::CallInit(this);
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = errors_;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

-->initialization

	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
	//delete errors;
	delete dummyToken;
}

Errors::Errors() {
	count = 0;
}

void Errors::SynErr(int line, int col, int n) {
	wchar_t* s;
	switch (n) {
-->errors
		default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	coco_string_delete(s);
	count++;
}

void Errors::Error(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	count++;
}

void Errors::Warning(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
}

void Errors::Warning(const wchar_t *s) {
	wprintf(L"%ls\n", s);
}

void Errors::Exception(const wchar_t* s) {
	wprintf(L"%ls", s); 
	exit(1);
}

Value* literalNumberRecord::calculate_numberValue_from_literal(){
	return new ValueTBD();
}

namespace ModTab{class Module;}

Value* Parser::DesignatorMaybeWithExprListRepeatingPartRecordCL1::calc(Parser* parser, identRecord* id1Ptr, SymbolTable &tab){
			identRecord id2; id2.ident_=clause1_identRec;
			struct Obj* obj = tab.Find(id1Ptr->ident_);
			if (obj==0) {
				tab.Err(L"Object not found");
				tab.Err(id1Ptr->ident_);
				return new ValueOfIdentDotIdent(*id1Ptr, id2);
			}else{
				if(obj->kind==OKscope && obj->type!=0 && obj->type->getTypeNumber()==type_number_MODULE) {
					wchar_t* dealiased=0;
					if(obj->data!=0){
						ModAliasRefDO* DO = (ModAliasRefDO*)(obj->data);
						dealiased=DO->modName;
					}
					else 
						dealiased = id1Ptr->ident_;
					ModTab::Module* m = parser->getmodtab()->Find(dealiased);
					if(m==0){
						tab.Err(L"module not found");tab.Err(id1Ptr->ident_);
						return new ValueOfIdentDotIdent(*id1Ptr, id2);
					}else{
						SymbolTable * tab2 = m->parser->tab;
						Obj* obj2 = tab2->Find(id2.ident_);
						if(obj2->kind==OKproc && obj2->type!=0 && obj2->type->getTypeNumber()==type_number_PROCEDURE &&
						 		((obj2->data) != 0) && obj2->data->getKind()==DeclSeqProcDOK){
								((DeclSeqProcDO*)(obj2->data))->DeclSeqProcPTR->callProcedure(m->parser);
						}
						return new ValueOfIdentDotIdent(*id1Ptr, id2);
					}
				}else{
					if(obj->kind==OKvar) {
						wprintf(L"\nVAR: %ls DOT %ls TYPE: ", id1Ptr->ident_, clause1_identRec); PRINT_TYPE_AS_STRING(obj->type);
						return new ValueOfIdentDotIdent(*id1Ptr, id2);
					}else{
						tab.Err(L"Must be OKMODULE or OKVAR, but is unknown");
						tab.Err(id1Ptr->ident_);
						return new ValueOfIdentDotIdent(*id1Ptr, id2);
					}
				}
		}
}

void Parser::StatementSeqRecord::interpret(Parser*p, CodeGenerator &codegen, SymbolTable &tab){
	codegen.InterpretStmtSeq(p, this, tab);
}

/* -->namespace_close */
